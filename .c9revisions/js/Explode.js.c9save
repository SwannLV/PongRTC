{"ts":1358100014739,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1358100018272,"patch":[[{"diffs":[[1,"/**\r\n * @author RX\r\n */\r\n//----------------------------------------------------------------------------\r\n// Class CExplode : generate a particle system based on a mesh to simulate an explosion\r\n//----------------------------------------------------------------------------\r\nCExplode = function(mesh, particlesCountBy100Pixels, particlesLifeTime) {\r\n    this.m_Particles = new THREE.Geometry ();\r\n\tthis.m_pMaterial = new THREE.ParticleBasicMaterial({color: 0xFFFFFF,size: 40,map: THREE.ImageUtils.loadTexture(\"images/GlowSphere.png\"), blending: THREE.AdditiveBlending, transparent: true});\r\n\tthis.m_iParticlesLifeTime = 1000;\r\n\tthis.m_iExplosionTime = 0;\r\n\tthis.m_fGravity = 0.0006;\r\n\tthis.m_arVelocity = new Array ();\r\n\tthis.m_ParticleSystem = new THREE.ParticleSystem (this.m_Particles, this.m_pMaterial);\r\n\tthis.init (mesh, particlesCountBy100Pixels, particlesLifeTime);\r\n\tthis.m_ParticleSystem.visible = false;\r\n\tthis.m_ParticleSystem.opacity = 0.5;\r\n\tthis.m_ParticleSystem.sortParticles = true;\r\n}\r\nCExplode.prototype.init = function(mesh, particlesCountBy100Pixels, particlesLifeTime) {\r\n\t// Le centre du mesh va servir de centre de l'explosion : on le calcule\r\n\tthis.m_iParticlesLifeTime = particlesLifeTime;\r\n\tthis.m_iExplosionTime = 0;\r\n\tvar vCenter  = new THREE.Vector3 (0, 0, 0); \r\n\tvar fBottomY = 0.0; \r\n\tif (mesh.geometry.vertices.length) {\r\n\t\tfBottomY = mesh.geometry.vertices [0].y;\r\n\t}\r\n\tfor (var i = 0; i < mesh.geometry.vertices.length; i++) {\r\n\t\tvP = mesh.geometry.vertices [i];\r\n\t\tvCenter.addSelf (vP);\r\n\t\tif (vP.y < fBottomY) fBottomY = vP.y;\r\n\t}\r\n\tvCenter.multiplyScalar (1.0 / mesh.geometry.vertices.length);\r\n\tvCenter.addSelf (mesh.position);\r\n\tvCenter.y = fBottomY;\r\n\t// On génère les particules représentant le mesh\r\n\tvar iParticleCount = 0;\r\n\tfor (var i = 0; i < mesh.geometry.faces.length; i++) {\r\n\t\tvar face = mesh.geometry.faces [i];\r\n\t\t// Calcul du nombre de particules pour cette face\r\n\t\tvar vA = mesh.geometry.vertices [face.a].clone ();\r\n\t\tvar vB = mesh.geometry.vertices [face.b].clone ();\r\n\t\tvar vC = mesh.geometry.vertices [face.c].clone ();\r\n\t\tvar vD = mesh.geometry.vertices [face.d].clone ();\r\n\t\tvar vAB = vB.clone (); vAB.subSelf (vA);\r\n\t\tvar vAD = vD.clone (); vAD.subSelf (vA);\r\n\t\tvar fAB = vAB.lengthSq ();\r\n\t\tvar fAD = vAD.lengthSq ();\r\n\t\tvar iNbFaceParticles = (fAB + fAD) * particlesCountBy100Pixels / 10000;\r\n\t\tfor (var p = 0; p < iNbFaceParticles; p++) {\r\n\t\t\tvar vP = vA.clone ();\r\n\t\t\tvar vPAB = vAB.clone ();\r\n\t\t\tvar vPAD = vAD.clone ();\r\n\t\t\tvPAB.multiplyScalar (Math.random ());\r\n\t\t\tvPAD.multiplyScalar (Math.random ());\r\n\t\t\tvP.addSelf (mesh.position);\r\n\t\t\tvP.addSelf (vPAB); \r\n\t\t\tvP.addSelf (vPAD); \r\n\t\t\tvar velocity = vP.clone (); velocity.subSelf (vCenter);\r\n\t\t\tvelocity.x *= 0.001 * (Math.random () + 1.);\r\n\t\t\tvelocity.y *= 0.005 * (Math.random () + 1.);\r\n\t\t\tvelocity.z *= 0.005 * (Math.random () + 1.);\r\n\t\t\tthis.m_arVelocity [iParticleCount] = velocity;\r\n\t\t\tthis.m_Particles.vertices [iParticleCount] = vP;\r\n\t\t\tiParticleCount++;\r\n\t\t}\r\n\t}\r\n\tthis.m_ParticleSystem.material.color = mesh.material.color;\r\n\tthis.m_ParticleSystem.geometry.verticesNeedUpdate = true;\r\n\tthis.m_ParticleSystem.visible = true;\r\n}\r\n// Update each particles\r\nCExplode.prototype.update = function(deltaTime) {\r\n\tif (this.m_ParticleSystem && this.m_ParticleSystem.visible) {\r\n\t\tvar delta = deltaTime;\r\n\t\tthis.m_iExplosionTime += delta;\r\n\t\tfor (var i = 0; i < this.m_Particles.vertices.length; i++) {\r\n\t\t\tvar particle = this.m_Particles.vertices[i];\r\n\t\t\tvar velocity = this.m_arVelocity[i];\r\n\t\t\tparticle.x += velocity.x * delta;\r\n\t\t\tparticle.y += velocity.y * delta;\r\n\t\t\tparticle.z += velocity.z * delta;\r\n\t\t\tif (particle.y < 0) particle.y = 100000; \r\n\t\t\tvelocity.y -= this.m_fGravity * delta;\r\n\t\t}\r\n\t\tif (this.m_iExplosionTime < this.m_iParticlesLifeTime) {\r\n\t\t\tthis.m_pMaterial.size = 40 * (1.0 - this.m_iExplosionTime / this.m_iParticlesLifeTime); \r\n\t\t} else {\r\n\t\t\tthis.m_pMaterial.size = 0;\r\n\t\t\tthis.m_ParticleSystem.visible = false;\r\n\t\t}\r\n\t\tthis.m_ParticleSystem.geometry.verticesNeedUpdate = true;\r\n\t}\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":4033}]],"length":4033,"saved":false}
