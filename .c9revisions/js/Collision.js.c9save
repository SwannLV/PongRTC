{"ts":1358099957084,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1358099960471,"patch":[[{"diffs":[[1,"/**\r\n * @author RX\r\n */\r\n//----------------------------------------------------------------------------\r\n// Class CCollidableFace : contains transformed points and normal of a face to collide with\r\n//----------------------------------------------------------------------------\r\nCCollidableFace = function(iFace, a, b, c, d, vN) {\r\n    this.m_iFace = iFace;\r\n\tthis.m_a = a;\r\n\tthis.m_b = b;\r\n\tthis.m_c = c;\r\n\tthis.m_d = d;\r\n\tthis.m_vN = new THREE.Vector3 (vN.x, vN.y, vN.z);\r\n}\r\n//----------------------------------------------------------------------------\r\n// Class CCollisionObject : object that can collide with the ball\r\n//----------------------------------------------------------------------------\r\nCCollisionObject = function(mesh, strName) {\r\n\tthis.m_Mesh = mesh;\r\n\tthis.m_Matrix = new THREE.Matrix4 ();\r\n\tthis.m_Velocity = new THREE.Vector3 (0, 0, 0);\r\n\tthis.m_fFriction = 2000.0;\r\n\tthis.m_fVelocityMax = 500.0;\r\n\tthis.m_strName = strName;\r\n\tthis.m_arFaces = new Array ();\t\t// Liste des faces utilisées pour les collision\r\n\tthis.m_arVertices = new Array ();\t// Liste des vertex transformés par la matrice de rotation de l'objet\r\n\tthis.applyRotations ();\r\n}\r\n// Add a collidable face for collisions system\r\nCCollisionObject.prototype.addColidableFace = function(iFace) {\r\n\tif (iFace < this.m_Mesh.geometry.faces.length) {\r\n\t\tvar face = this.m_Mesh.geometry.faces [iFace];\r\n\t\tthis.m_arFaces [this.m_arFaces.length] = new CCollidableFace (iFace, face.a, face.b, face.c, face.d, face.normal);\r\n\t}\r\n\treturn this\r\n}\r\n// Add a collidable face for collisions system according to its normal\r\nCCollisionObject.prototype.addColidableFaceFromNormal = function(vNormal) {\r\n\tvar i;\r\n\tvar bFound = false;\r\n\tfor (i = 0; !bFound && (i < this.m_Mesh.geometry.faces.length); i++) {\r\n\t\tvar vFaceNormal = this.m_Mesh.geometry.faces [i].normal;\r\n\t\tbFound = vFaceNormal.x == vNormal.x && vFaceNormal.y == vNormal.y && vFaceNormal.z == vNormal.z;\r\n\t\tif (bFound) this.addColidableFace (i)\r\n\t} \r\n\treturn bFound\r\n}\r\n// Make all faces of the object collidables\r\nCCollisionObject.prototype.makeAllFacesColidable = function() {\r\n\tvar i;\r\n\tfor (i = 0; i < this.m_Mesh.geometry.faces.length; i++) this.addColidableFace (i); \r\n\treturn this\r\n}\r\n// Move the object\r\nCCollisionObject.prototype.move = function(x, y, z) {\r\n\tthis.m_Mesh.position.x = x;\r\n\tthis.m_Mesh.position.y = y;\r\n\tthis.m_Mesh.position.z = z;\r\n\tthis.m_Matrix.elements [12] = this.m_Mesh.position.x;\r\n\tthis.m_Matrix.elements [13] = this.m_Mesh.position.y;\r\n\tthis.m_Matrix.elements [14] = this.m_Mesh.position.z;\r\n\treturn this\r\n}\r\n// Add a centered rotation to the object \r\nCCollisionObject.prototype.addRotation = function(x, y, z) {\r\n\tthis.m_Mesh.rotation.x += x;\r\n\tthis.m_Mesh.rotation.y += y;\r\n\tthis.m_Mesh.rotation.z += z;\r\n\treturn this\r\n}\r\n// Add a velocity vector to the current velocity of the object\r\nCCollisionObject.prototype.addVelocity = function(x, y, z) {\r\n\tthis.m_Velocity.x += x;\r\n\tthis.m_Velocity.y += y;\r\n\tthis.m_Velocity.z += z;\r\n\tvar fLength = this.m_Velocity.length ();\r\n\tif (fLength > this.m_fVelocityMax) \r\n\t{\r\n\t\tvar fReduction = this.m_fVelocityMax / fLength;\r\n\t\tthis.m_Velocity.x *= fReduction;\r\n\t\tthis.m_Velocity.y *= fReduction;\r\n\t\tthis.m_Velocity.z *= fReduction;\r\n\t}\r\n\treturn this\r\n}\r\n// Update object position according to its velocity\r\nCCollisionObject.prototype.update = function(deltaTime) {\r\n\tthis.m_Mesh.position.x += this.m_Velocity.x * deltaTime;\r\n\tthis.m_Mesh.position.y += this.m_Velocity.y * deltaTime;\r\n\tthis.m_Mesh.position.z += this.m_Velocity.z * deltaTime;\r\n\tif (this.m_Velocity.x > 0) {\r\n\t\tthis.m_Velocity.x -= deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.x < 0) this.m_Velocity.x = 0;\r\n\t} else if (this.m_Velocity.x < 0) {\r\n\t\tthis.m_Velocity.x += deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.x > 0) this.m_Velocity.x = 0;\r\n\t}\r\n\tif (this.m_Velocity.y > 0) {\r\n\t\tthis.m_Velocity.y -= deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.y < 0) this.m_Velocity.y = 0;\r\n\t} else if (this.m_Velocity.y < 0) {\r\n\t\tthis.m_Velocity.y += deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.y > 0) this.m_Velocity.y = 0;\r\n\t}\r\n\tif (this.m_Velocity.z > 0) {\r\n\t\tthis.m_Velocity.z -= deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.z < 0) this.m_Velocity.z = 0;\r\n\t} else if (this.m_Velocity.z < 0) {\r\n\t\tthis.m_Velocity.z += deltaTime * this.m_fFriction;\r\n\t\tif (this.m_Velocity.z > 0) this.m_Velocity.z = 0;\r\n\t}\r\n\tthis.move (this.m_Mesh.position.x, this.m_Mesh.position.y, this.m_Mesh.position.z);\r\n\treturn this\r\n}\r\n// Apply all the rotations to the object\r\nCCollisionObject.prototype.applyRotations = function() {\r\n\tthis.m_Matrix.identity ();\r\n\tthis.m_Matrix.setRotationFromEuler (this.m_Mesh.rotation, \"\");\r\n\tthis.move (this.m_Mesh.position.x, this.m_Mesh.position.y, this.m_Mesh.position.z);\r\n\tthis.applyTransformation ();\r\n\treturn this\r\n}\r\n// Apply transformation matrix to vertices and normals\r\nCCollisionObject.prototype.applyTransformation = function() {\r\n\tvar i;\r\n\tfor (i = 0; i < this.m_Mesh.geometry.vertices.length; i++) {\r\n\t\tvar v = this.m_Mesh.geometry.vertices [i];\r\n\t\tvar vTransform = new THREE.Vector3 (v.x, v.y, v.z);\r\n\t\tapplyRotationMatrix (vTransform, this.m_Matrix);\r\n\t\tthis.m_arVertices [i] = vTransform;\r\n\t}\r\n\tfor (i = 0; i < this.m_arFaces.length; i++) {\r\n\t\tvar collidableFace = this.m_arFaces [i];\r\n\t\tvar face = this.m_Mesh.geometry.faces [collidableFace.m_iFace];\r\n\t\tcollidableFace.m_vN = new THREE.Vector3 (face.normal.x, face.normal.y, face.normal.z);\r\n\t\tapplyRotationMatrix (collidableFace.m_vN, this.m_Matrix);\r\n\t}\r\n}\r\n//----------------------------------------------------------------------------\r\n// Class CCollision : manage collisions between scene elements and the ball\r\n//----------------------------------------------------------------------------\r\nCCollision = function() {\r\n\tthis.m_ObjectArray = new Array();\r\n\tthis.m_DebugArray  = new Array()\r\n}\r\n// Add an object to the collision system\r\nCCollision.prototype.add = function(object) {\r\n\tthis.m_ObjectArray [this.m_ObjectArray.length] = object;\r\n\treturn this\r\n}\r\n// Compute collisions between the moving ball and all registered objects\r\nCCollision.prototype.collide = function(vPosStart, vPosStop, Ball) {\r\n\tvar i = 0;\r\n\tvar bCollided = false;\r\n\t// On parcours tous les mesh pour voir s'il y a collision avec ces derniers\r\n\tfor (i = 0; i < this.m_ObjectArray.length; i++) {\r\n\t\tbCollided = this.collideMesh (vPosStart, vPosStop, Ball, this.m_ObjectArray [i]) || bCollided \r\n\t}\r\n\treturn bCollided\r\n}\r\n// Compute collisions between the moving ball and one registered object\r\nCCollision.prototype.collideMesh = function(vPosStart, vPosStop, Ball, object) {\r\n\tvar i = 0;\r\n\tvar bCollided = false;\r\n\tvar bFoundCollision = true;\r\n\tvar fBallRadius = Ball.m_fRadius;\r\n\t\r\n\t// On recommence tant qu'on trouve une collision\r\n\twhile (bFoundCollision) {\r\n\t\t// Calculs préalables\r\n\t\tvar vStartStop = new THREE.Vector3 (vPosStop.x - vPosStart.x, vPosStop.y - vPosStart.y, vPosStop.z - vPosStart.z);\r\n\t\t// On parcours toutes les faces du mesh pour trouver la collision la plus proche s'il y en a\r\n\t\tvar iFaceCollided = -1;\r\n\t\tvar fMinDist = 10000.0;\r\n\t\tvar vCollisionCenter;\r\n\t\tvar vCollisionProjection;\r\n\t\tvar vCollisionNormal;\r\n\t\tbFoundCollision = false;\r\n\t\tiFaceCollided = -1;\r\n\t\tfor (i = 0; i < object.m_arFaces.length; i++) {\r\n\t\t\t// On récupère la face du mesh à traiter\r\n\t\t\tvar collidableFace = object.m_arFaces [i];\r\n\t\t\tvar vA = new THREE.Vector3 (object.m_arVertices [collidableFace.m_a].x + object.m_Mesh.position.x, object.m_arVertices [collidableFace.m_a].y + object.m_Mesh.position.y, object.m_arVertices [collidableFace.m_a].z + object.m_Mesh.position.z);\r\n\t\t\tvar vB = new THREE.Vector3 (object.m_arVertices [collidableFace.m_b].x + object.m_Mesh.position.x, object.m_arVertices [collidableFace.m_b].y + object.m_Mesh.position.y, object.m_arVertices [collidableFace.m_b].z + object.m_Mesh.position.z);\r\n\t\t\tvar vC = new THREE.Vector3 (object.m_arVertices [collidableFace.m_c].x + object.m_Mesh.position.x, object.m_arVertices [collidableFace.m_c].y + object.m_Mesh.position.y, object.m_arVertices [collidableFace.m_c].z + object.m_Mesh.position.z);\r\n\t\t\tvar vD = new THREE.Vector3 (object.m_arVertices [collidableFace.m_d].x + object.m_Mesh.position.x, object.m_arVertices [collidableFace.m_d].y + object.m_Mesh.position.y, object.m_arVertices [collidableFace.m_d].z + object.m_Mesh.position.z);\r\n\t\t\tvar vN = new THREE.Vector3 (collidableFace.m_vN.x, collidableFace.m_vN.y, collidableFace.m_vN.z); \r\n\t\t\t// La première chose à faire est de vérifier que le point de départ n'est pas en collision avec la face\r\n\t\t\t// On calcule le vecteur entre le point de départ et un point de la face \r\n\t\t\tvar vAS = new THREE.Vector3 (vPosStart.x - vA.x, vPosStart.y - vA.y, vPosStart.z - vA.z);\r\n\t\t\t// On calcule la distance entre la face et le centre de la balle grace au vecteur vAS\r\n\t\t\tvar fDistFaceCenter = vAS.dot (vN);\r\n\t\t\t// Si la face est à une distance inférieure au rayon de la balle, on vérifie si la balle touche réellement la face et pas simplement le plan de la face  \r\n\t\t\tif (Math.abs (fDistFaceCenter) < fBallRadius) {\r\n\t\t\t\t// On calcule la projection de vPosStart sur le plan de la face\r\n\t\t\t\tvar vStartProj = new THREE.Vector3 (vPosStart.x - vN.x * fDistFaceCenter, vPosStart.y - vN.y * fDistFaceCenter, vPosStart.z - vN.z * fDistFaceCenter);\r\n\t\t\t\t// Et on vérifie si le point est bien dans le cadre de la face\r\n\t\t\t\tif (isPointIntoQuad (vA, vB, vC, vD, vN, vStartProj)) {\r\n\t\t\t\t\t// Il y a collision avec la face : il faut immédiatement déplacer la balle pour éviter la collision\r\n\t\t\t\t\tvar fMoveDistToAvoidCollision = fBallRadius - fDistFaceCenter;\r\n\t\t\t\t\tvar vAvoidCollision = new THREE.Vector3 (vN.x * fMoveDistToAvoidCollision, vN.y * fMoveDistToAvoidCollision, vN.z * fMoveDistToAvoidCollision);\r\n\t\t\t\t\tvPosStart.addSelf (vAvoidCollision);\r\n\t\t\t\t\tvPosStop.addSelf (vAvoidCollision);\r\n\t\t\t\t\t// Ce déplacement ajoute également à la vitesse de la balle dans la direction de déplacement\r\n\t\t\t\t\t// Ainsi que la vitesse de déplacement de l'objet\r\n\t\t\t\t\tBall.addVelocity (vAvoidCollision.x + object.m_Velocity.x * 0.001, vAvoidCollision.y + object.m_Velocity.y * 0.001, vAvoidCollision.z + object.m_Velocity.z * 0.001);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Ensuite le but est de calculer le moment où la balle touche la face et si c'est entre vPosStart et vPosStop\r\n\t\t\tvar fDotN = vStartStop.dot (vN);\r\n\t\t\t// On vérifie d'abord que la normale n'est pas perpendiculaire à la trajectoire (fDotN = 0) sinon il n'y aura pas de collision\r\n\t\t\t// Et que sa direction est bien opposée au mouvement (fDotN > 0 => dans le même sens)\r\n\t\t\tif (fDotN < 0.0) {\r\n\t\t\t\t// Et on cherche le point sur vStartStop qui est à la distance fBallRadius de la face\r\n\t\t\t\t//    fDist correspond a un facteur qui multiplié par vStartStop donne la position du centre de la balle lors de l'impact \r\n\t\t\t\t//    (si fDist = 0 le point d'intersection est vPosStart, si fDist = 1 le point d'intersection est vPosStop)\r\n\t\t\t\tvar fDist = (fBallRadius - fDistFaceCenter) / fDotN;\r\n\t\t\t\t\r\n\t\t\t\t// On n'inclu pas le 0 qui signifirait qu'on prend en compte la collision avec le point de départ ce qui pourrait nous faire tomber dans une boucle infinie \r\n\t\t\t\tif (fDist > 0.0 && fDist <= 1.0) {\r\n\t\t\t\t\t// On vient de trouver un point sur la trajectoire qui est à une distance de fBallRadius du plan infini formé par un point de la face et sa normale\r\n\t\t\t\t\tvar vI = new THREE.Vector3 (vPosStart.x + vStartStop.x * fDist, vPosStart.y + vStartStop.y * fDist, vPosStart.z + vStartStop.z * fDist);\r\n\t\t\t\t\t// On calcule le projeté sur le plan de la face\r\n\t\t\t\t\tvar vH = new THREE.Vector3 (vI.x - vN.x * fBallRadius, vI.y - vN.y * fBallRadius, vI.z - vN.z * fBallRadius);\r\n\t\t\t\t\t// Maintenant il faut vérifier que la balle touche bien le cadre de la face en cette position et n'est pas en dehors\r\n\t\t\t\t\tif (isPointIntoQuad (vA, vB, vC, vD, vN, vH)) {\r\n\t\t\t\t\t\t// On vient de trouver un point de collision, s'il est plus proche que les autres on le garde pour la suite\r\n\t\t\t\t\t\tif (!bFoundCollision || (fDist < fMinDist)) {\r\n\t\t\t\t\t\t\tiFaceCollided = i;\r\n\t\t\t\t\t\t\tfMinDist = fDist;\r\n\t\t\t\t\t\t\tvCollisionCenter = vI;\r\n\t\t\t\t\t\t\tvCollisionNormal = vN;\r\n\t\t\t\t\t\t\tvCollisionProjection = vH;\r\n\t\t\t\t\t\t\tbFoundCollision = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\t\t\t\t\t \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (bFoundCollision) {\r\n\t\t\t// Il y a collision : on gère le rebond \r\n\t\t\t// On commence par récupérer la position de rebond\r\n\t\t\tvar vC = vCollisionCenter;\r\n\t\t\t// Puis on calcule le symétrique de vPosStop par rapport à vC\r\n\t\t\tvar fDistSym = (fMinDist * 2.0) - 1.0;\r\n\t\t\tvar vSym = new THREE.Vector3 (vPosStart.x + fDistSym * vStartStop.x, vPosStart.y + fDistSym * vStartStop.y, vPosStart.z + fDistSym * vStartStop.z);\r\n\t\t\t// Ensuite on calcule le projeté de vSym sur face.normal\r\n\t\t\tvar vCSym = new THREE.Vector3 (vSym.x - vC.x, vSym.y - vC.y, vSym.z - vC.z);\r\n\t\t\tvar fHProj = vCollisionNormal.dot (vCSym);\r\n\t\t\tvar vProj = new THREE.Vector3 (vC.x + vCollisionNormal.x * fHProj, vC.y + vCollisionNormal.y * fHProj, vC.z + vCollisionNormal.z * fHProj);\r\n\t\t\t// Enfin on calcule le symetrique de vSym par rapport à vProj\r\n\t\t\t// Et par la même occasion on redéfinie les positions de départ et d'arrivée\r\n\t\t\tvPosStart.x = vC.x;\r\n\t\t\tvPosStart.y = vC.y;\r\n\t\t\tvPosStart.z = vC.z;\r\n\t\t\tvPosStop.x = vProj.x + vProj.x - vSym.x;\r\n\t\t\tvPosStop.y = vProj.y + vProj.y - vSym.y;\r\n\t\t\tvPosStop.z = vProj.z + vProj.z - vSym.z;\r\n\t\t\t// On ajoute à la balle la vitesse actuelle de déplacement de l'objet\r\n\t\t\tvPosStop.x += object.m_Velocity.x * 0.001;\r\n\t\t\tvPosStop.y += object.m_Velocity.y * 0.001;\r\n\t\t\tvPosStop.z += object.m_Velocity.z * 0.001;\r\n\t\t}\r\n\t\tbCollided = bCollided || bFoundCollision; \r\n\t}\r\n\treturn bCollided\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":13627}]],"length":13627,"saved":false}
