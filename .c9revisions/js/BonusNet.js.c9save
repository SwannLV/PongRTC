{"ts":1358099921648,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1358099925583,"patch":[[{"diffs":[[1,"/**\r\n * @author RX\r\n */\r\n// Bonuses types :\r\nvar BonusType = {\"SlideMore\" : 0, \"SlideLess\" : 1, \"BallSpeedMore\" : 2, \"BallSpeedLess\" : 3, \"BallSizeMore\" : 4, \"BallSizeLess\" : 5, \"ChangeBallDirection\" : 6, \"RotateCamera\" : 7};\r\n//----------------------------------------------------------------------------\r\n// Class CNetElement : description and animation of a net element\r\n//----------------------------------------------------------------------------\r\nCNetElement = function(pos, width) {\r\n    this.m_fHalfWidth = width/2;\r\n\tthis.m_fWidthCenter = this.m_fHalfWidth/8;\r\n\tthis.m_fHalfHeight = 25;\r\n\tthis.m_fHalfDepth = 10;\r\n\tvar NetMaterial = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0.8} );\r\n\tvar NetGeometry = new THREE.CubeGeometry (width, this.m_fHalfHeight * 2, this.m_fHalfDepth * 2);\r\n\tthis.m_Mesh = new THREE.Mesh(NetGeometry, NetMaterial);\r\n\tthis.m_Mesh.position.x = pos.x;\r\n\tthis.m_Mesh.position.y = pos.y + this.m_fHalfHeight;\r\n\tthis.m_Mesh.position.z = pos.z;\r\n\tthis.m_iState = 0;\r\n\tthis.m_iBonus = -1;\r\n\tthis.m_fAnimTime = 0.0;\r\n\tthis.m_fAnimTimeStart = 0.0;\r\n\tthis.m_fAnimTimeEnd = 1.0;\r\n\tthis.m_fRotationFactor = 1.0;\r\n\tthis.m_Explode = new CExplode (this.m_Mesh, 20, 1000);\r\n}\r\n// Update the net element according to its state and the relative position of the ball\r\nCNetElement.prototype.update = function(Ball, deltaTime, arBonuses) {\r\n\t// On commence par calculer la distance de la balle\r\n\tvar bBonusUpdated = false;\r\n\tvar iCollisionType = 0;\r\n\tvar fDiffZ = Ball.m_Mesh.position.z - this.m_Mesh.position.z;\r\n\tvar fDiffX = Ball.m_Mesh.position.x - this.m_Mesh.position.x;\r\n\t\r\n\tif (Math.abs (fDiffZ) <= this.m_fHalfDepth + Ball.m_fRadius)\t{\r\n\t\t// La balle est assez proche pour rentrer en collision sur la profondeur : on vérifie la hauteur\r\n\t\tvar fDiffY = Ball.m_Mesh.position.y - this.m_Mesh.position.y;\r\n\t\tif (Math.abs (fDiffY) <= this.m_fHalfHeight + Ball.m_fRadius) {\r\n\t\t\t// La balle est assez proche pour rentrer en collision sur la hauteur : on vérifie la distance sur la lageur\r\n\t\t\tif (Math.abs (fDiffX) <= this.m_fHalfWidth + Ball.m_fRadius) {\r\n\t\t\t\t// Il y a collision mais on distingue 2 types de collision, proche du centre (1) ou éloigné (2)\r\n\t\t\t\tif (Math.abs (fDiffX) <= this.m_fWidthCenter + Ball.m_fRadius) {\r\n\t\t\t\t\tiCollisionType = 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tiCollisionType = 2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Ensuite on gère le comportement de l'élément en fonction de son état\r\n\tswitch (this.m_iState) {\r\n\t\tcase 0: // inactif\r\n\t\tif (iCollisionType == 1) {\r\n\t\t\t// On passe dans l'état destruction inactive\r\n\t\t\tthis.m_fAnimTimeStart = Date.now();\r\n\t\t\tthis.m_fAnimTime = this.m_fAnimTimeStart;\r\n\t\t\tthis.m_fAnimTimeEnd = this.m_fAnimTimeStart + 2000; \r\n\t\t\tthis.m_Mesh.visible = false;\r\n\t\t\tthis.m_Explode.init (this.m_Mesh, 20, this.m_fAnimTimeEnd - this.m_fAnimTimeStart);\r\n\t\t\tthis.m_iState = 2;\r\n\t\t}\r\n\t\telse if (iCollisionType == 2) {\r\n\t\t\t// On passe dans l'état rotation avant activation du bonus\r\n\t\t\tthis.m_fAnimTimeStart = Date.now();\r\n\t\t\tthis.m_fAnimTime = this.m_fAnimTimeStart;\r\n\t\t\tthis.m_fAnimTimeEnd = this.m_fAnimTimeStart + 1000; \r\n\t\t\tif (fDiffX * fDiffZ > 0) {\r\n\t\t\t\tthis.m_fRotationFactor = 1.0; \r\n\t\t\t} else {\r\n\t\t\t\tthis.m_fRotationFactor = -1.0; \r\n\t\t\t}\r\n\t\t\tthis.m_iState = 1;\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase 1: // inactif en rotation\r\n\t\tthis.m_fAnimTime += deltaTime;\r\n\t\tif (this.m_fAnimTime >= this.m_fAnimTimeEnd) {\r\n\t\t\t// Rotation terminée : on active un bonus\r\n\t\t\tthis.m_Mesh.rotation.y = 0;\r\n\t\t\tthis.m_Mesh.material = new THREE.MeshPhongMaterial( { color: 0xFF0000, transparent: true, opacity: 0.9} );\r\n\t\t\tthis.m_iBonus = Math.round (Math.random () * (arBonuses.length - 1));\r\n\t\t\tthis.m_iState = 3;\r\n\t\t} else {\r\n\t\t\t// Rotation en cours\r\n\t\t\tvar fDeltaRotation = Math.sin ((this.m_fAnimTime - this.m_fAnimTimeStart) * Math.PI / (2 * (this.m_fAnimTimeEnd - this.m_fAnimTimeStart)));\r\n\t\t\tthis.m_Mesh.rotation.y = 4 * Math.PI * fDeltaRotation * this.m_fRotationFactor;\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase 2: // inactif en destruction\r\n\t\tthis.m_fAnimTime += deltaTime;\r\n\t\tif (this.m_fAnimTime >= this.m_fAnimTimeEnd) {\r\n\t\t\t// Destruction terminee : on passe a l'état apparition\r\n\t\t\tthis.m_Mesh.visible = true;\r\n\t\t\tthis.m_Mesh.scale.x = 0;\r\n\t\t\tthis.m_Mesh.scale.y = 0;\r\n\t\t\tthis.m_Mesh.scale.z = 0;\r\n\t\t\tthis.m_fAnimTimeStart = Date.now();\r\n\t\t\tthis.m_fAnimTime = this.m_fAnimTimeStart;\r\n\t\t\tthis.m_fAnimTimeEnd = this.m_fAnimTimeStart + 1000; \r\n\t\t\tthis.m_Mesh.material = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0.9} );\r\n\t\t\tthis.m_iState = 6;\r\n\t\t} else {\r\n\t\t\t/*\r\n\t\t\t// TODO : faire exploser le cube\r\n\t\t\t// Pour le moment je réduit la taille de l'élément jusqu'à 0 en effectuant un petit rebond a mi chemin\r\n\t\t\t// Pour faire ça en fonction du temps j'utilise le polynome de Berstein de degrès 3 \r\n\t\t\t// B(t) = P0*(1-t)^3 + 3*P1*t*(1-t)^2 + 3*P2*t^2*(1-t) + P3*t^3\r\n\t\t\t// avec P0=1, P1=-1, P2=1, P3=0\r\n\t\t\tvar fTime = (this.m_fAnimTime - this.m_fAnimTimeStart) / (this.m_fAnimTimeEnd - this.m_fAnimTimeStart);\r\n\t\t\tvar fInvTime = 1 - fTime; \r\n\t\t\t//var fScale = fInvTime*fInvTime*fInvTime + 0.75*fTime*fInvTime*fInvTime + 2.25*fTime*fTime*fInvTime;\r\n\t\t\tvar fScale = fInvTime*fInvTime*fInvTime - 3*fTime*fInvTime*fInvTime + 3*fTime*fTime*fInvTime;\r\n\t\t\tthis.m_Mesh.scale.x = fScale;\r\n\t\t\tthis.m_Mesh.scale.y = fScale;\r\n\t\t\tthis.m_Mesh.scale.z = fScale;\r\n\t\t\t*/\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase 3: // bonus activé, en attente de la balle\r\n\t\tif (iCollisionType == 1) {\r\n\t\t\t// On passe dans l'état destruction et activation du bonus\r\n\t\t\tthis.m_fAnimTimeStart = Date.now();\r\n\t\t\tthis.m_fAnimTime = this.m_fAnimTimeStart;\r\n\t\t\tthis.m_fAnimTimeEnd = this.m_fAnimTimeStart + 1000; \r\n\t\t\tarBonuses [this.m_iBonus]++;\r\n\t\t\tbBonusUpdated = true;\r\n\t\t\tthis.m_iState = 5;\r\n\t\t}\r\n\t\telse if (iCollisionType == 2) {\r\n\t\t\t// On passe dans l'état rotation pour revenir a l'état inactif\r\n\t\t\tthis.m_fAnimTimeStart = Date.now();\r\n\t\t\tthis.m_fAnimTime = this.m_fAnimTimeStart;\r\n\t\t\tthis.m_fAnimTimeEnd = this.m_fAnimTimeStart + 1000; \r\n\t\t\tif (fDiffX * fDiffZ > 0) {\r\n\t\t\t\tthis.m_fRotationFactor = 1.0; \r\n\t\t\t} else {\r\n\t\t\t\tthis.m_fRotationFactor = -1.0; \r\n\t\t\t}\r\n\t\t\tthis.m_iState = 4;\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase 4: // bonus activé, en rotation\r\n\t\tthis.m_fAnimTime += deltaTime;\r\n\t\tif (this.m_fAnimTime >= this.m_fAnimTimeEnd) {\r\n\t\t\t// Rotation terminée : on désactive le bonus\r\n\t\t\tthis.m_Mesh.rotation.y = 0;\r\n\t\t\tthis.m_Mesh.material = new THREE.MeshPhongMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0.9} );\r\n\t\t\tthis.m_iBonus = 0;\r\n\t\t\tthis.m_iState = 0;\r\n\t\t} else {\r\n\t\t\t// Rotation en cours\r\n\t\t\tvar fDeltaRotation = Math.sin ((this.m_fAnimTime - this.m_fAnimTimeStart) * Math.PI / (2 * (this.m_fAnimTimeEnd - this.m_fAnimTimeStart)));\r\n\t\t\tthis.m_Mesh.rotation.y = 4 * Math.PI * fDeltaRotation * this.m_fRotationFactor;\r\n\t\t}\r\n\t\tbreak;\r\n\t\tcase 5: // bonus activé, en destruction\r\n\t\t// TODO : envoyer le bonus sur le frontend\r\n\t\t// Pour le moment je détruit de la même manière que lorsque c'est inactif\r\n\t\tthis.m_Mesh.visible = false;\r\n\t\tthis.m_Explode.init (this.m_Mesh, 20, this.m_fAnimTimeEnd - this.m_fAnimTimeStart);\r\n\t\tthis.m_iState = 2;\r\n\t\tbreak;\r\n\t\tcase 6: // apparition\r\n\t\tthis.m_fAnimTime += deltaTime;\r\n\t\tif (this.m_fAnimTime >= this.m_fAnimTimeEnd) {\r\n\t\t\t// Apparition terminee : on passe a l'état inactif\r\n\t\t\tthis.m_Mesh.scale.x = 1;\r\n\t\t\tthis.m_Mesh.scale.y = 1;\r\n\t\t\tthis.m_Mesh.scale.z = 1;\r\n\t\t\tthis.m_iState = 0;\r\n\t\t} else {\r\n\t\t\t// TODO : faire exploser le cube\r\n\t\t\t// Pour le moment je réduit la taille de l'élément jusqu'à 0 en effectuant un petit rebond a mi chemin\r\n\t\t\t// Pour faire ça en fonction du temps j'utilise le polynome de Berstein de degrès 3 \r\n\t\t\t// B(t) = P0*(1-t)^3 + 3*P1*t*(1-t)^2 + 3*P2*t^2*(1-t) + P3*t^3\r\n\t\t\t// avec P0=0, P1=2, P2=-1, P3=1\r\n\t\t\tvar fTime = (this.m_fAnimTime - this.m_fAnimTimeStart) / (this.m_fAnimTimeEnd - this.m_fAnimTimeStart);\r\n\t\t\tvar fInvTime = 1 - fTime; \r\n\t\t\tvar fScale = 6*fTime*fInvTime*fInvTime - 3*fTime*fTime*fInvTime + fTime*fTime*fTime;\r\n\t\t\tthis.m_Mesh.scale.x = fScale;\r\n\t\t\tthis.m_Mesh.scale.y = fScale;\r\n\t\t\tthis.m_Mesh.scale.z = fScale;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\t\r\n\tthis.m_Explode.update (deltaTime);\r\n\t\r\n\treturn bBonusUpdated;\r\n}\r\n//----------------------------------------------------------------------------\r\n// Class CBonusNet : manages bonuses and options\r\n//----------------------------------------------------------------------------\r\nCBonusNet = function(scene, elementsCount, arenaHalfWidth) {\r\n\tthis.m_arElement = new Array ();\r\n\tthis.m_arBonuses = new Array ();\r\n\tthis.m_bBonusesUpdated = false;\r\n\tvar NetElementWidth = arenaHalfWidth * 2 / elementsCount;\r\n\tvar NetElementPos = -arenaHalfWidth + NetElementWidth / 2;\r\n\tvar i;\r\n\tfor (i = 0; i < elementsCount; i++) {\r\n\t\tthis.m_arElement [i] = new CNetElement (new THREE.Vector3 (NetElementPos, 0, 0), NetElementWidth);\r\n\t\tNetElementPos += NetElementWidth;\r\n\t\tscene.add(this.m_arElement [i].m_Mesh);\r\n\t\tscene.add(this.m_arElement [i].m_Explode.m_ParticleSystem);\r\n\t}\r\n\tfor (i = 0; i < BonusType.length; i++)\r\n\t{\r\n\t\tthis.m_arBonuses [i] = 0;\r\n\t}\r\n}\r\n// Update the net and bonuses\r\nCBonusNet.prototype.update = function(Ball, deltaTime) {\r\n\tvar i;\r\n\tfor (i = 0; i < this.m_arElement.length; i++) {\r\n\t\tthis.m_bBonusesUpdated = this.m_arElement [i].update (Ball, deltaTime, this.m_arBonuses) || this.m_bBonusesUpdated;\r\n\t}\r\n\treturn this\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":9288}]],"length":9288,"saved":false}
